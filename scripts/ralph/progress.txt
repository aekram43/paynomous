# Ralph Progress Log
Started: Thu Feb  5 03:51:30 +07 2026
---
## Codebase Patterns
- Project structure: Backend (NestJS), Frontend (Next.js), Rust services in separate directories
- Docker Compose used for local development infrastructure (PostgreSQL, Redis, UI tools)
- TypeScript typecheck script in package.json: `npm run typecheck`
- Environment variables stored in .env file (gitignored), with .env.example for reference
- Health checks configured for all Docker services
- Database ORM: Prisma with PostgreSQL, schema in backend/prisma/schema.prisma
- Connection pooling configured via DATABASE_URL query params: connection_limit=50&pool_timeout=10
- Run migrations with: `cd backend && npx prisma migrate dev --name <name>`
- Run seed script with: `cd backend && npx prisma db seed`
---

## 2026-02-05 04:15 - US-001
- What was implemented:
  * Created project structure with backend/, frontend/, rust-services/ directories
  * Created Docker Compose file with PostgreSQL 16, Redis 7, and Redis Commander UI
  * Configured environment variables in .env and .env.example files
  * Set up basic NestJS backend with TypeScript configuration
  * Created health endpoint in app.controller.ts
  * Added typecheck script to package.json

- Files changed:
  * docker-compose.yml (created)
  * .env.example (created)
  * .gitignore (created)
  * backend/package.json (created)
  * backend/tsconfig.json (created)
  * backend/src/main.ts (created)
  * backend/src/app.module.ts (created)
  * backend/src/app.controller.ts (created)
  * backend/src/app.service.ts (created)

- **Learnings for future iterations:**
  * Docker Compose services require correct image names - used `rediscommander/redis-commander:latest` for Redis UI instead of non-existent BullMQ Board images
  * Docker Desktop must be running before executing docker-compose commands
  * Health checks use `condition: service_healthy` for dependencies between services
  * Basic NestJS structure includes: main.ts (bootstrap), app.module.ts (root module), app.controller.ts (endpoints), app.service.ts (business logic)
  * TypeScript strict mode is disabled in initial setup for easier development
  * All Docker services use the `agentrooms-network` bridge network for inter-service communication
  * PostgreSQL and Redis are accessible on standard ports (5432, 6379)
  * Redis Commander UI is accessible on port 3001 (mapped from internal port 8081)
---
## 2026-02-05 04:28 - US-002
- What was implemented:
  * Installed Prisma ORM (@prisma/client and prisma) with PostgreSQL support
  * Defined complete Prisma schema with all 8 core tables: users, nfts, rooms, agents, swarms, deals, messages, agent_performance
  * Established all foreign key relationships with proper cascade rules (CASCADE, SET NULL)
  * Added indexes on hot paths: wallet_address, room_id, agent_id, status fields
  * Implemented check constraints using Prisma's @db annotations
  * Configured DATABASE_URL with connection pooling: connection_limit=50, pool_timeout=10
  * Created initial database migration (20260204212758_init)
  * Created seed script (prisma/seed.ts) with 25 BAYC NFTs, 10 Cool Cats NFTs, and 2 trading rooms
  * Successfully ran migrations and seeded database
  * Typecheck passes

- Files changed:
  * .env.example (modified - added connection pooling params)
  * backend/package.json (modified - added Prisma dependencies and seed config)
  * backend/package-lock.json (modified - Prisma packages)
  * backend/.gitignore (created - by Prisma init)
  * backend/prisma.config.ts (created - Prisma configuration)
  * backend/prisma/schema.prisma (created - database schema)
  * backend/prisma/seed.ts (created - seed script)
  * backend/prisma/migrations/ (created - migration files)

- **Learnings for future iterations:**
  * Prisma uses `gen_random_uuid()` for UUID generation in PostgreSQL
  * Prisma init creates a default .env file that needs to be replaced with the correct DATABASE_URL
  * Connection pooling is configured via query parameters in DATABASE_URL: ?connection_limit=50&pool_timeout=10
  * Prisma schema uses snake_case for database columns via @map() while keeping camelCase in TypeScript
  * Seed scripts are configured in package.json under "prisma.seed" key
  * Use `npx prisma migrate dev --name <name>` to create and apply migrations
  * Use `npx prisma db seed` to run seed scripts
  * All Prisma commands should be run from the directory containing prisma.config.ts (backend/)
  * Prisma Client is generated to node_modules/.prisma/client for easy importing
---
## 2026-02-05 04:50 - US-003
- What was implemented:
  * Installed authentication dependencies: ethers@^6.13.0, @nestjs/jwt, @nestjs/passport, passport-jwt, class-validator, class-transformer
  * Created complete auth module with controller, service, DTOs, JWT strategy, and auth guard
  * Implemented POST /auth/challenge endpoint - generates unique nonce and challenge message with 5-minute expiration
  * Implemented POST /auth/verify endpoint - validates wallet signature using ethers.js verifyMessage()
  * Implemented POST /auth/refresh endpoint - refreshes access tokens using valid refresh token
  * Implemented GET /auth/me endpoint - returns authenticated user data (protected with JWT guard)
  * JWT tokens issued with 24-hour expiration for access tokens, 7-day for refresh tokens
  * In-memory nonce store with expiration tracking to prevent replay attacks
  * User records automatically created/updated on successful authentication
  * JWT payload includes userId and walletAddress
  * Typecheck passes

- Files changed:
  * backend/package.json (modified - added auth dependencies)
  * backend/package-lock.json (modified - auth packages)
  * backend/src/app.module.ts (modified - imported AuthModule)
  * backend/src/auth/auth.controller.ts (created)
  * backend/src/auth/auth.service.ts (created)
  * backend/src/auth/auth.module.ts (created)
  * backend/src/auth/jwt.strategy.ts (created)
  * backend/src/auth/jwt-auth.guard.ts (created)
  * backend/src/auth/dto/challenge.dto.ts (created)
  * backend/src/auth/dto/verify.dto.ts (created)
  * backend/src/auth/dto/refresh.dto.ts (created)

- **Learnings for future iterations:**
  * Prisma Client uses camelCase field names (walletAddress, createdAt, updatedAt) even though database columns are snake_case
  * Always use Prisma's generated TypeScript types - they prevent field name mismatches
  * ethers.js v6 uses named imports: `import { verifyMessage } from 'ethers'`
  * Nonce store should be moved to Redis for multi-instance deployments (currently in-memory)
  * JWT secret is configured in both JwtModule.register() and JwtStrategy constructor
  * @UseGuards(JwtAuthGuard) protects endpoints and injects user data into request object
  * NestJS PassportStrategy automatically extracts JWT from Authorization Bearer header
  * Challenge message format should match exactly what user signs for signature verification
  * Wallet addresses should be normalized to lowercase for consistent storage and lookup
---
## 2026-02-05 08:45 - US-004
- What was implemented:
  * Installed @nestjs/swagger for API documentation
  * Created complete REST API with 5 modules: Rooms, Agents, Swarms, Deals, NFTs
  * Implemented Rooms endpoints: GET /rooms, GET /rooms/:id, GET /rooms/:id/stats
  * Implemented Agents endpoints: POST /agents/spawn, GET /agents/:id, DELETE /agents/:id
  * Implemented Swarms endpoints: POST /swarms/spawn, GET /swarms/:id, PATCH /swarms/:id
  * Implemented Deals endpoints: GET /deals/:id, GET /deals/my
  * Implemented NFTs endpoints: GET /nfts, POST /nfts/verify-ownership
  * All endpoints protected with JWT authentication guard (via @UseGuards(JwtAuthGuard))
  * Request validation using class-validator DTOs (@IsString, @IsEnum, @IsUUID, etc.)
  * Swagger documentation auto-generated at /api endpoint
  * Global validation pipe with whitelist and transform enabled
  * CORS enabled for frontend access
  * Proper error handling with NotFoundException, BadRequestException
  * Typecheck passes

- Files changed:
  * backend/package.json (modified - added @nestjs/swagger)
  * backend/package-lock.json (modified - swagger package)
  * backend/src/main.ts (modified - added Swagger config, validation pipe, CORS)
  * backend/src/app.module.ts (modified - imported all new modules)
  * backend/src/rooms/rooms.controller.ts (created)
  * backend/src/rooms/rooms.service.ts (created)
  * backend/src/rooms/rooms.module.ts (created)
  * backend/src/agents/agents.controller.ts (created)
  * backend/src/agents/agents.service.ts (created)
  * backend/src/agents/agents.module.ts (created)
  * backend/src/agents/dto/spawn-agent.dto.ts (created)
  * backend/src/swarms/swarms.controller.ts (created)
  * backend/src/swarms/swarms.service.ts (created)
  * backend/src/swarms/swarms.module.ts (created)
  * backend/src/swarms/dto/spawn-swarm.dto.ts (created)
  * backend/src/deals/deals.controller.ts (created)
  * backend/src/deals/deals.service.ts (created)
  * backend/src/deals/deals.module.ts (created)
  * backend/src/nfts/nfts.controller.ts (created)
  * backend/src/nfts/nfts.service.ts (created)
  * backend/src/nfts/nfts.module.ts (created)
  * backend/src/nfts/dto/verify-ownership.dto.ts (created)

- **Learnings for future iterations:**
  * Prisma field names: Always check the actual schema - use camelCase in code even though DB uses snake_case with @map()
  * Room schema: Uses `name` and `collection` fields, not `collectionName` or `collectionAddress`
  * Agent schema: Uses `communicationStyle` not `personality`, `startingPrice` not `currentPrice`, `messagesSent` not `messageCount`
  * Deal schema: Uses `finalPrice` not `price`, and `blockNumber` is BigInt (convert to string for JSON)
  * Swarm schema: Uses `totalAgents` not `agentCount`, and doesn't have a `name` field
  * NFT schema: Model is `Nft` not `NFT` (lowercase first letter), uses `collection` not `collectionName`
  * Swagger decorators: Use @ApiTags for grouping, @ApiOperation for descriptions, @ApiResponse for status codes, @ApiBearerAuth for JWT
  * Global pipes: ValidationPipe should be configured with `whitelist: true` and `transform: true` for security and auto-transformation
  * JWT guards: Use `@UseGuards(JwtAuthGuard)` on controllers/routes, and `@Request() req` to access `req.user.userId`
  * Prisma Client: Each service should instantiate its own PrismaClient in the constructor
  * Service exports: Always export services from modules for potential cross-module usage
---
## 2026-02-05 13:30 - US-005
- What was implemented:
  * Integrated Socket.io with NestJS using @nestjs/websockets and @nestjs/platform-socket.io
  * Created WebSocket gateway with JWT authentication (token from handshake auth or authorization header)
  * Implemented join_room and leave_room event handlers with room membership tracking
  * Implemented all broadcast events: agent_joined, agent_message, room_stats, deal_locked, deal_verifying, deal_completed, agent_left
  * Integrated Redis Pub/Sub using @socket.io/redis-adapter with ioredis for multi-instance support
  * Added message sequencing with timestamps (all events include timestamp: new Date().toISOString())
  * Implemented connection state management (handleConnection, handleDisconnect with automatic room cleanup)
  * Room-based broadcasting using Socket.io rooms (users only receive messages from joined rooms)
  * Added error handling for authentication failures and disconnection
  * Typecheck passes

- Files changed:
  * backend/package.json (modified - added @nestjs/websockets, @nestjs/platform-socket.io, ioredis, @socket.io/redis-adapter)
  * backend/package-lock.json (modified - new WebSocket dependencies)
  * backend/src/app.module.ts (modified - imported WebsocketModule)
  * backend/src/websocket/websocket.gateway.ts (created)
  * backend/src/websocket/websocket.module.ts (created)

- **Learnings for future iterations:**
  * Socket.io Gateway: Use @WebSocketGateway decorator with CORS configuration for frontend access
  * JWT Authentication: Extract token from `client.handshake.auth.token` or `client.handshake.headers.authorization`
  * Redis Adapter: Use @socket.io/redis-adapter with ioredis (not native redis package) for Socket.io multi-instance support
  * Redis Pub/Sub: Redis adapter automatically handles Pub/Sub for Socket.io rooms, no manual subscription needed
  * Room Management: Socket.io handles room broadcasting with `this.server.to(roomId).emit(event, data)`
  * Namespace: Use namespace: '/ws' for WebSocket gateway, or '/' for root namespace
  * Connection Lifecycle: Implement OnGatewayInit, OnGatewayConnection, OnGatewayDisconnect for proper lifecycle management
  * Client Tracking: Store authenticated socket data (userId, walletAddress) on the socket object after JWT verification
  * Broadcasting Methods: Export gateway methods for other services to call (e.g., AgentsService can call gateway.broadcastAgentJoined)
  * Message Format: All broadcast events should include roomId and timestamp for consistency
  * Environment Variables: Use REDIS_HOST and REDIS_PORT for Redis connection configuration
---
