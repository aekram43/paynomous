# Ralph Progress Log
Started: Thu Feb  5 03:51:30 +07 2026
---
## Codebase Patterns
- Project structure: Backend (NestJS), Frontend (Next.js), Rust services in separate directories
- Docker Compose used for local development infrastructure (PostgreSQL, Redis, UI tools)
- TypeScript typecheck script in package.json: `npm run typecheck`
- Environment variables stored in .env file (gitignored), with .env.example for reference
- Health checks configured for all Docker services
- Database ORM: Prisma with PostgreSQL, schema in backend/prisma/schema.prisma
- Connection pooling configured via DATABASE_URL query params: connection_limit=50&pool_timeout=10
- Run migrations with: `cd backend && npx prisma migrate dev --name <name>`
- Run seed script with: `cd backend && npx prisma db seed`
---

## 2026-02-05 04:15 - US-001
- What was implemented:
  * Created project structure with backend/, frontend/, rust-services/ directories
  * Created Docker Compose file with PostgreSQL 16, Redis 7, and Redis Commander UI
  * Configured environment variables in .env and .env.example files
  * Set up basic NestJS backend with TypeScript configuration
  * Created health endpoint in app.controller.ts
  * Added typecheck script to package.json

- Files changed:
  * docker-compose.yml (created)
  * .env.example (created)
  * .gitignore (created)
  * backend/package.json (created)
  * backend/tsconfig.json (created)
  * backend/src/main.ts (created)
  * backend/src/app.module.ts (created)
  * backend/src/app.controller.ts (created)
  * backend/src/app.service.ts (created)

- **Learnings for future iterations:**
  * Docker Compose services require correct image names - used `rediscommander/redis-commander:latest` for Redis UI instead of non-existent BullMQ Board images
  * Docker Desktop must be running before executing docker-compose commands
  * Health checks use `condition: service_healthy` for dependencies between services
  * Basic NestJS structure includes: main.ts (bootstrap), app.module.ts (root module), app.controller.ts (endpoints), app.service.ts (business logic)
  * TypeScript strict mode is disabled in initial setup for easier development
  * All Docker services use the `agentrooms-network` bridge network for inter-service communication
  * PostgreSQL and Redis are accessible on standard ports (5432, 6379)
  * Redis Commander UI is accessible on port 3001 (mapped from internal port 8081)
---
## 2026-02-05 04:28 - US-002
- What was implemented:
  * Installed Prisma ORM (@prisma/client and prisma) with PostgreSQL support
  * Defined complete Prisma schema with all 8 core tables: users, nfts, rooms, agents, swarms, deals, messages, agent_performance
  * Established all foreign key relationships with proper cascade rules (CASCADE, SET NULL)
  * Added indexes on hot paths: wallet_address, room_id, agent_id, status fields
  * Implemented check constraints using Prisma's @db annotations
  * Configured DATABASE_URL with connection pooling: connection_limit=50, pool_timeout=10
  * Created initial database migration (20260204212758_init)
  * Created seed script (prisma/seed.ts) with 25 BAYC NFTs, 10 Cool Cats NFTs, and 2 trading rooms
  * Successfully ran migrations and seeded database
  * Typecheck passes

- Files changed:
  * .env.example (modified - added connection pooling params)
  * backend/package.json (modified - added Prisma dependencies and seed config)
  * backend/package-lock.json (modified - Prisma packages)
  * backend/.gitignore (created - by Prisma init)
  * backend/prisma.config.ts (created - Prisma configuration)
  * backend/prisma/schema.prisma (created - database schema)
  * backend/prisma/seed.ts (created - seed script)
  * backend/prisma/migrations/ (created - migration files)

- **Learnings for future iterations:**
  * Prisma uses `gen_random_uuid()` for UUID generation in PostgreSQL
  * Prisma init creates a default .env file that needs to be replaced with the correct DATABASE_URL
  * Connection pooling is configured via query parameters in DATABASE_URL: ?connection_limit=50&pool_timeout=10
  * Prisma schema uses snake_case for database columns via @map() while keeping camelCase in TypeScript
  * Seed scripts are configured in package.json under "prisma.seed" key
  * Use `npx prisma migrate dev --name <name>` to create and apply migrations
  * Use `npx prisma db seed` to run seed scripts
  * All Prisma commands should be run from the directory containing prisma.config.ts (backend/)
  * Prisma Client is generated to node_modules/.prisma/client for easy importing
---
## 2026-02-05 04:50 - US-003
- What was implemented:
  * Installed authentication dependencies: ethers@^6.13.0, @nestjs/jwt, @nestjs/passport, passport-jwt, class-validator, class-transformer
  * Created complete auth module with controller, service, DTOs, JWT strategy, and auth guard
  * Implemented POST /auth/challenge endpoint - generates unique nonce and challenge message with 5-minute expiration
  * Implemented POST /auth/verify endpoint - validates wallet signature using ethers.js verifyMessage()
  * Implemented POST /auth/refresh endpoint - refreshes access tokens using valid refresh token
  * Implemented GET /auth/me endpoint - returns authenticated user data (protected with JWT guard)
  * JWT tokens issued with 24-hour expiration for access tokens, 7-day for refresh tokens
  * In-memory nonce store with expiration tracking to prevent replay attacks
  * User records automatically created/updated on successful authentication
  * JWT payload includes userId and walletAddress
  * Typecheck passes

- Files changed:
  * backend/package.json (modified - added auth dependencies)
  * backend/package-lock.json (modified - auth packages)
  * backend/src/app.module.ts (modified - imported AuthModule)
  * backend/src/auth/auth.controller.ts (created)
  * backend/src/auth/auth.service.ts (created)
  * backend/src/auth/auth.module.ts (created)
  * backend/src/auth/jwt.strategy.ts (created)
  * backend/src/auth/jwt-auth.guard.ts (created)
  * backend/src/auth/dto/challenge.dto.ts (created)
  * backend/src/auth/dto/verify.dto.ts (created)
  * backend/src/auth/dto/refresh.dto.ts (created)

- **Learnings for future iterations:**
  * Prisma Client uses camelCase field names (walletAddress, createdAt, updatedAt) even though database columns are snake_case
  * Always use Prisma's generated TypeScript types - they prevent field name mismatches
  * ethers.js v6 uses named imports: `import { verifyMessage } from 'ethers'`
  * Nonce store should be moved to Redis for multi-instance deployments (currently in-memory)
  * JWT secret is configured in both JwtModule.register() and JwtStrategy constructor
  * @UseGuards(JwtAuthGuard) protects endpoints and injects user data into request object
  * NestJS PassportStrategy automatically extracts JWT from Authorization Bearer header
  * Challenge message format should match exactly what user signs for signature verification
  * Wallet addresses should be normalized to lowercase for consistent storage and lookup
---
## 2026-02-05 08:45 - US-004
- What was implemented:
  * Installed @nestjs/swagger for API documentation
  * Created complete REST API with 5 modules: Rooms, Agents, Swarms, Deals, NFTs
  * Implemented Rooms endpoints: GET /rooms, GET /rooms/:id, GET /rooms/:id/stats
  * Implemented Agents endpoints: POST /agents/spawn, GET /agents/:id, DELETE /agents/:id
  * Implemented Swarms endpoints: POST /swarms/spawn, GET /swarms/:id, PATCH /swarms/:id
  * Implemented Deals endpoints: GET /deals/:id, GET /deals/my
  * Implemented NFTs endpoints: GET /nfts, POST /nfts/verify-ownership
  * All endpoints protected with JWT authentication guard (via @UseGuards(JwtAuthGuard))
  * Request validation using class-validator DTOs (@IsString, @IsEnum, @IsUUID, etc.)
  * Swagger documentation auto-generated at /api endpoint
  * Global validation pipe with whitelist and transform enabled
  * CORS enabled for frontend access
  * Proper error handling with NotFoundException, BadRequestException
  * Typecheck passes

- Files changed:
  * backend/package.json (modified - added @nestjs/swagger)
  * backend/package-lock.json (modified - swagger package)
  * backend/src/main.ts (modified - added Swagger config, validation pipe, CORS)
  * backend/src/app.module.ts (modified - imported all new modules)
  * backend/src/rooms/rooms.controller.ts (created)
  * backend/src/rooms/rooms.service.ts (created)
  * backend/src/rooms/rooms.module.ts (created)
  * backend/src/agents/agents.controller.ts (created)
  * backend/src/agents/agents.service.ts (created)
  * backend/src/agents/agents.module.ts (created)
  * backend/src/agents/dto/spawn-agent.dto.ts (created)
  * backend/src/swarms/swarms.controller.ts (created)
  * backend/src/swarms/swarms.service.ts (created)
  * backend/src/swarms/swarms.module.ts (created)
  * backend/src/swarms/dto/spawn-swarm.dto.ts (created)
  * backend/src/deals/deals.controller.ts (created)
  * backend/src/deals/deals.service.ts (created)
  * backend/src/deals/deals.module.ts (created)
  * backend/src/nfts/nfts.controller.ts (created)
  * backend/src/nfts/nfts.service.ts (created)
  * backend/src/nfts/nfts.module.ts (created)
  * backend/src/nfts/dto/verify-ownership.dto.ts (created)

- **Learnings for future iterations:**
  * Prisma field names: Always check the actual schema - use camelCase in code even though DB uses snake_case with @map()
  * Room schema: Uses `name` and `collection` fields, not `collectionName` or `collectionAddress`
  * Agent schema: Uses `communicationStyle` not `personality`, `startingPrice` not `currentPrice`, `messagesSent` not `messageCount`
  * Deal schema: Uses `finalPrice` not `price`, and `blockNumber` is BigInt (convert to string for JSON)
  * Swarm schema: Uses `totalAgents` not `agentCount`, and doesn't have a `name` field
  * NFT schema: Model is `Nft` not `NFT` (lowercase first letter), uses `collection` not `collectionName`
  * Swagger decorators: Use @ApiTags for grouping, @ApiOperation for descriptions, @ApiResponse for status codes, @ApiBearerAuth for JWT
  * Global pipes: ValidationPipe should be configured with `whitelist: true` and `transform: true` for security and auto-transformation
  * JWT guards: Use `@UseGuards(JwtAuthGuard)` on controllers/routes, and `@Request() req` to access `req.user.userId`
  * Prisma Client: Each service should instantiate its own PrismaClient in the constructor
  * Service exports: Always export services from modules for potential cross-module usage
---
## 2026-02-05 13:30 - US-005
- What was implemented:
  * Integrated Socket.io with NestJS using @nestjs/websockets and @nestjs/platform-socket.io
  * Created WebSocket gateway with JWT authentication (token from handshake auth or authorization header)
  * Implemented join_room and leave_room event handlers with room membership tracking
  * Implemented all broadcast events: agent_joined, agent_message, room_stats, deal_locked, deal_verifying, deal_completed, agent_left
  * Integrated Redis Pub/Sub using @socket.io/redis-adapter with ioredis for multi-instance support
  * Added message sequencing with timestamps (all events include timestamp: new Date().toISOString())
  * Implemented connection state management (handleConnection, handleDisconnect with automatic room cleanup)
  * Room-based broadcasting using Socket.io rooms (users only receive messages from joined rooms)
  * Added error handling for authentication failures and disconnection
  * Typecheck passes

- Files changed:
  * backend/package.json (modified - added @nestjs/websockets, @nestjs/platform-socket.io, ioredis, @socket.io/redis-adapter)
  * backend/package-lock.json (modified - new WebSocket dependencies)
  * backend/src/app.module.ts (modified - imported WebsocketModule)
  * backend/src/websocket/websocket.gateway.ts (created)
  * backend/src/websocket/websocket.module.ts (created)

- **Learnings for future iterations:**
  * Socket.io Gateway: Use @WebSocketGateway decorator with CORS configuration for frontend access
  * JWT Authentication: Extract token from `client.handshake.auth.token` or `client.handshake.headers.authorization`
  * Redis Adapter: Use @socket.io/redis-adapter with ioredis (not native redis package) for Socket.io multi-instance support
  * Redis Pub/Sub: Redis adapter automatically handles Pub/Sub for Socket.io rooms, no manual subscription needed
  * Room Management: Socket.io handles room broadcasting with `this.server.to(roomId).emit(event, data)`
  * Namespace: Use namespace: '/ws' for WebSocket gateway, or '/' for root namespace
  * Connection Lifecycle: Implement OnGatewayInit, OnGatewayConnection, OnGatewayDisconnect for proper lifecycle management
  * Client Tracking: Store authenticated socket data (userId, walletAddress) on the socket object after JWT verification
  * Broadcasting Methods: Export gateway methods for other services to call (e.g., AgentsService can call gateway.broadcastAgentJoined)
  * Message Format: All broadcast events should include roomId and timestamp for consistency
  * Environment Variables: Use REDIS_HOST and REDIS_PORT for Redis connection configuration
---
## 2026-02-05 13:45 - US-006
- What was implemented:
  * Created Redis module with RedisService using ioredis for all Redis operations
  * Connected Redis client with proper error handling and retry strategy
  * Implemented Pub/Sub clients (separate connections for pub/sub operations)
  * Implemented NFT metadata caching with 1 hour TTL (cacheNftMetadata/getNftMetadata)
  * Implemented user session caching with 24 hour TTL (cacheUserSession/getUserSession/deleteUserSession)
  * Implemented live stats using sorted sets for floor prices and bids (room:{roomId}:floor and room:{roomId}:bids)
  * Implemented room stats caching with 5 second TTL (cacheRoomStats/getRoomStats)
  * Implemented rate limiting counters with time windows (incrementRateLimit/checkRateLimit)
  * Implemented WebSocket session tracking (trackWebSocketSession/getWebSocketSession/deleteWebSocketSession)
  * Integrated Redis caching into existing services: NftsService, RoomsService, AuthService, WebsocketGateway
  * Updated AuthService to use Redis for nonce storage (replacing in-memory Map)
  * Updated RoomsService to cache stats with 5 second TTL (check cache before DB query)
  * Updated NftsService to cache metadata after fetching from DB
  * Updated WebsocketGateway to track sessions in Redis on connect/disconnect
  * Typecheck passes

- Files changed:
  * backend/src/redis/redis.service.ts (created)
  * backend/src/redis/redis.module.ts (created)
  * backend/src/app.module.ts (modified - imported RedisModule)
  * backend/src/auth/auth.service.ts (modified - use Redis for nonces and sessions)
  * backend/src/nfts/nfts.service.ts (modified - cache NFT metadata)
  * backend/src/rooms/rooms.service.ts (modified - cache room stats)
  * backend/src/websocket/websocket.gateway.ts (modified - track WebSocket sessions)

- **Learnings for future iterations:**
  * Redis Module: Use @Global() decorator to make RedisService available throughout the app without importing RedisModule in each module
  * ioredis: Use ioredis package (not native redis) for NestJS Redis integration - better TypeScript support
  * Redis Connections: Separate Redis clients needed for Pub/Sub vs regular operations (pubClient, subClient, client)
  * Retry Strategy: Implement exponential backoff with `retryStrategy: (times) => Math.min(times * 50, 2000)`
  * Error Handling: Redis operations should log errors but not throw - fail gracefully to prevent app crashes
  * TTL Strategy: Use setex(key, ttl, value) for keys with expiration, set(key, value) for permanent keys
  * Sorted Sets: Use zadd for adding scores, zrange for ascending order, zrevrange for descending order, WITHSCORES to get values with scores
  * Rate Limiting: Use pipeline for atomic operations (incr + expire) to prevent race conditions
  * Cache Invalidation: Explicitly delete cache keys when data changes (e.g., after user logout, deal completion)
  * Module Lifecycle: Implement OnModuleInit and OnModuleDestroy for connection management
  * Nonce Storage: Redis is better than in-memory Map for multi-instance deployments (survives restarts, shared across instances)
  * Cache Pattern: Always check cache first, fetch from DB on miss, then update cache for next request
  * WebSocket Sessions: Track connection metadata in Redis for monitoring and debugging
  * Pub/Sub Channels: Use consistent naming pattern like `room:{roomId}` for room-specific channels
---
## 2026-02-05 13:40 - US-007
- What was implemented:
  * Integrated BullMQ with NestJS using @nestjs/bullmq package
  * Created QueuesModule with Redis connection configuration (host, port from environment)
  * Implemented five job queues: glm-requests, deal-verification, analytics, cleanup, notifications
  * Created five processor workers with @Processor decorators extending WorkerHost
  * GlmProcessor: Handles GLM API requests with 3 retries, exponential backoff, concurrency 5
  * DealVerificationProcessor: Processes deal verification with 2 retries, concurrency 3
  * AnalyticsProcessor: Calculates room stats and agent performance, concurrency 2
  * CleanupProcessor: Handles old message cleanup and deal archival, concurrency 1
  * NotificationsProcessor: Sends email, push, and webhook notifications with 2 retries, concurrency 5
  * Configured job priorities via defaultJobOptions (attempts, backoff, removeOnComplete, removeOnFail)
  * Implemented worker event handlers (OnWorkerEvent) for completed and failed jobs
  * Set appropriate timeouts and retry strategies with exponential backoff per queue type
  * Redis Commander UI accessible on port 3001 for queue monitoring

- Files changed:
  * backend/src/app.module.ts (added QueuesModule import)
  * backend/src/queues/queues.module.ts (created)
  * backend/src/queues/processors/glm.processor.ts (created)
  * backend/src/queues/processors/deal-verification.processor.ts (created)
  * backend/src/queues/processors/analytics.processor.ts (created)
  * backend/src/queues/processors/cleanup.processor.ts (created)
  * backend/src/queues/processors/notifications.processor.ts (created)

- **Learnings for future iterations:**
  * BullMQ Integration: Use @nestjs/bullmq package, not the base bullmq package directly
  * Module Configuration: BullMQ requires forRoot() with Redis connection, then registerQueue() for each queue
  * Processor Pattern: Extend WorkerHost class and use @Processor('queue-name') decorator with concurrency option
  * Job Options: Configure defaultJobOptions at queue registration time (attempts, backoff, removeOnComplete, removeOnFail)
  * Retry Strategies: Use exponential backoff with delay starting at 1000-2000ms for critical operations
  * Worker Events: Use @OnWorkerEvent('completed') and @OnWorkerEvent('failed') decorators for lifecycle hooks
  * Job Data Types: Define TypeScript interfaces for job data to ensure type safety (e.g., GlmRequestJob, DealVerificationJob)
  * Concurrency: Set appropriate concurrency per processor based on resource intensity (1-5 range is typical)
  * Queue Naming: Use kebab-case for queue names to match BullMQ conventions (glm-requests, not glmRequests)
  * Job Cleanup: Configure removeOnComplete and removeOnFail to prevent Redis memory bloat
  * Dashboard: Redis Commander (port 3001) can be used to monitor BullMQ queues stored in Redis
  * Placeholder Logic: All processors have placeholder implementations with TODO comments for future US completion
  * Error Handling: Always log errors with stack traces in failed event handlers for debugging
  * Job Processing: process() method receives Job<T> with typed data property containing job payload
---
## 2026-02-05 14:30 - US-008
- What was implemented:
  * Created GlmModule and GlmService for GLM API integration
  * Installed axios for HTTP requests to GLM API
  * Implemented complete system prompt template builder with:
    - Agent personality injection (name, role, communication style)
    - Price mandate enforcement (min/max/starting prices)
    - Room context integration (floor price, top bid, competitor counts)
    - Recent chat history for context-aware responses
  * Built user message template for trigger events
  * Implemented strategy-specific instructions for all 5 strategies:
    - Competitive: Monitor and react to market changes dynamically
    - Patient: Keep steady price, wait for good offers
    - Aggressive: Undercut competitors, close deals fast
    - Conservative: Start cautious, slowly adjust based on market
    - Sniper: Watch quietly, strike at perfect opportunity
  * Added communication style support for all 4 styles with detailed guidance:
    - Formal: Professional and polite language with proper grammar
    - Casual: Friendly and approachable with contractions
    - Professional: Direct business language focused on facts
    - Aggressive: Bold and assertive with confident language
  * Configured GLM API client:
    - Endpoint: https://api.z.ai/api/paas/v4/chat/completions
    - Model: glm-4
    - Temperature: 0.8 (for creative responses)
    - Max tokens: 150 (keep responses concise)
    - 10 second timeout
  * Implemented comprehensive error handling:
    - Rate limit detection (429 status)
    - Authentication failure detection (401 status)
    - Generic API failure handling with logging
  * Updated GlmProcessor to use new GlmService with proper dependency injection
  * Integrated with BullMQ glm-requests queue (existing queue now functional)
  * Implemented response processing:
    - Price extraction using regex pattern matching
    - Intent detection (offer, counter, accept, reject, comment) based on keywords
    - Sentiment analysis (positive, negative, neutral) based on emotion words
  * Updated .env.example with correct GLM API configuration (Z.AI endpoint)
  * Updated QueuesModule to import GlmModule
  * Updated AppModule to import GlmModule globally
  * Typecheck passes

- Files changed:
  * backend/package.json (added axios dependency)
  * backend/package-lock.json (axios packages)
  * backend/src/glm/glm.module.ts (created)
  * backend/src/glm/glm.service.ts (created - 600+ lines)
  * backend/src/queues/processors/glm.processor.ts (modified - integrated GlmService)
  * backend/src/queues/queues.module.ts (modified - imported GlmModule)
  * backend/src/app.module.ts (modified - imported GlmModule)
  * .env.example (modified - updated GLM API URL to Z.AI endpoint)
  * scripts/ralph/prd.json (modified - set US-008 passes to true)

- **Learnings for future iterations:**
  * GLM API uses Z.AI endpoint (https://api.z.ai/api/paas/v4) not generic glm.com
  * GLM API follows OpenAI-compatible format for chat completions
  * System prompts should be comprehensive but concise - include all context agents need to make decisions
  * Strategy instructions should be specific and actionable, not generic advice
  * Communication style guidance should include concrete examples agents can follow
  * Intent detection requires keyword-based heuristics since GLM doesn't return structured data
  * Price extraction from natural language requires regex pattern matching
  * Sentiment analysis can be basic (positive/negative/neutral word counting) for MVP
  * BullMQ processors need proper dependency injection in constructor (call super() after injecting services)
  * Error handling for external APIs should distinguish between rate limits, auth failures, and generic errors
  * Temperature 0.8 balances creativity with coherence for chat-style responses
  * Max tokens 150 keeps agent messages concise and chat-friendly
  * Response processing should extract structured data (price, intent, sentiment) for database storage
  * GLM service should be globally available since multiple modules may need it (agents, swarms, etc.)
---
